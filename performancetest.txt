==================
Perfomance testing
==================

This module implements a performance testing function that let you specify
 the maximum time allowed for a given callable object.

The code comes into two flavors: a decorator and a regular wrapper so
it can be used into unit tests and doctests as well.

It is based on pystone to be portable on any computer,
and also provide a tolerance value if the CPU is busy when it runs.

For this reason this kind of measurement is not precise, 
but fullfill a need: a performance regression warning tool.

A critical piece of code can therefore be protected if it is slowed down
 by some changes made: the test just complains that the code became too slow.

Example of use
--------------

In unit tests, with the `timedtest` decorator:

  >>> from zope.app.testing.performancetest import timedtest
  >>> import unittest
  >>> class MesTests(unittest.TestCase):
  ...     def __init__(self, name):
  ...         unittest.TestCase.__init__(self, name)
  ...     @timedtest(2000)
  ...     def test_critical(self):
  ...         a =''
  ...         for i in range(50000):
  ...             a = a + 'x' * 200
  >>> suite = unittest.makeSuite(MesTests)
  >>> unittest.TextTestRunner().run(suite)
  <unittest._TextTestResult run=1 errors=0 failures=0>

In doc tests, with a wrapper:

  >>> from zope.app.testing.performancetest import wtimedtest
  >>> def test_critical():
  ...     a =''
  ...     for i in range(50000):
  ...         a = a + 'x' * 200
  ...     return 0
  >>> wtimedtest(test_critical, 2000)()
  0


The module also provide `local_pystone`, that can be reused, to avoid
calculating local pystones every time the test is ran:

  >>> from zope.app.testing.performancetest import local_pystone, wtimedtest
  >>> lstone = local_pystone()
  >>> def test_critical():
  ...     a =''
  ...     for i in range(50000):
  ...         a = a + 'x' * 200
  ...     return 0
  >>> wtimedtest(test_critical, 2000, lstone)()
  0
  >>> import unittest
  >>> class MesTests(unittest.TestCase):
  ...     def __init__(self, name):
  ...         unittest.TestCase.__init__(self, name)
  ...     @timedtest(2000, lstone)
  ...     def test_critical(self):
  ...         a =''
  ...         for i in range(50000):
  ...             a = a + 'x' * 200
  >>> suite = unittest.makeSuite(MesTests)
  >>> unittest.TextTestRunner().run(suite)
  <unittest._TextTestResult run=1 errors=0 failures=0>


Checking the performance tester is not lying
--------------------------------------------

This should not fail:

  >>> from test import pystone
  >>> import time
  >>> stime, stone = pystone.pystones(loops=pystone.LOOPS)
  >>> def onepystone():
  ...     time.sleep(stime)
  >>> wtimedtest(onepystone, pystone.LOOPS, lstone)()

